// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "Types.pb.h"
// @@protoc_insertion_point(imports)

@implementation BTypesRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [BTypesRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    [ObjectivecDescriptorRoot registerAllExtensions:registry];
    extensionRegistry = registry;
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface BTimestamp ()
@property Float64 epoch;
@end

@implementation BTimestamp

- (BOOL) hasEpoch {
  return !!hasEpoch_;
}
- (void) setHasEpoch:(BOOL) _value_ {
  hasEpoch_ = !!_value_;
}
@synthesize epoch;
- (instancetype) init {
  if ((self = [super init])) {
    self.epoch = 0;
  }
  return self;
}
static BTimestamp* defaultBTimestampInstance = nil;
+ (void) initialize {
  if (self == [BTimestamp class]) {
    defaultBTimestampInstance = [[BTimestamp alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBTimestampInstance;
}
- (instancetype) defaultInstance {
  return defaultBTimestampInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasEpoch) {
    [output writeDouble:1 value:self.epoch];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasEpoch) {
    size_ += computeDoubleSize(1, self.epoch);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BTimestamp*) parseFromData:(NSData*) data {
  return (BTimestamp*)[[[BTimestamp builder] mergeFromData:data] build];
}
+ (BTimestamp*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BTimestamp*)[[[BTimestamp builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BTimestamp*) parseFromInputStream:(NSInputStream*) input {
  return (BTimestamp*)[[[BTimestamp builder] mergeFromInputStream:input] build];
}
+ (BTimestamp*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BTimestamp*)[[[BTimestamp builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BTimestamp*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BTimestamp*)[[[BTimestamp builder] mergeFromCodedInputStream:input] build];
}
+ (BTimestamp*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BTimestamp*)[[[BTimestamp builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BTimestampBuilder*) builder {
  return [[BTimestampBuilder alloc] init];
}
+ (BTimestampBuilder*) builderWithPrototype:(BTimestamp*) prototype {
  return [[BTimestamp builder] mergeFrom:prototype];
}
- (BTimestampBuilder*) builder {
  return [BTimestamp builder];
}
- (BTimestampBuilder*) toBuilder {
  return [BTimestamp builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasEpoch) {
    [output appendFormat:@"%@%@: %@\n", indent, @"epoch", [NSNumber numberWithDouble:self.epoch]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasEpoch) {
    [dictionary setObject: [NSNumber numberWithDouble:self.epoch] forKey: @"epoch"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BTimestamp class]]) {
    return NO;
  }
  BTimestamp *otherMessage = other;
  return
      self.hasEpoch == otherMessage.hasEpoch &&
      (!self.hasEpoch || self.epoch == otherMessage.epoch) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasEpoch) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.epoch] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BTimestampBuilder()
@property (strong) BTimestamp* resultTimestamp;
@end

@implementation BTimestampBuilder
@synthesize resultTimestamp;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultTimestamp = [[BTimestamp alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultTimestamp;
}
- (BTimestampBuilder*) clear {
  self.resultTimestamp = [[BTimestamp alloc] init];
  return self;
}
- (BTimestampBuilder*) clone {
  return [BTimestamp builderWithPrototype:resultTimestamp];
}
- (BTimestamp*) defaultInstance {
  return [BTimestamp defaultInstance];
}
- (BTimestamp*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BTimestamp*) buildPartial {
  BTimestamp* returnMe = resultTimestamp;
  self.resultTimestamp = nil;
  return returnMe;
}
- (BTimestampBuilder*) mergeFrom:(BTimestamp*) other {
  if (other == [BTimestamp defaultInstance]) {
    return self;
  }
  if (other.hasEpoch) {
    [self setEpoch:other.epoch];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BTimestampBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BTimestampBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 9: {
        [self setEpoch:[input readDouble]];
        break;
      }
    }
  }
}
- (BOOL) hasEpoch {
  return resultTimestamp.hasEpoch;
}
- (Float64) epoch {
  return resultTimestamp.epoch;
}
- (BTimestampBuilder*) setEpoch:(Float64) value {
  resultTimestamp.hasEpoch = YES;
  resultTimestamp.epoch = value;
  return self;
}
- (BTimestampBuilder*) clearEpoch {
  resultTimestamp.hasEpoch = NO;
  resultTimestamp.epoch = 0;
  return self;
}
@end

@interface BTimespan ()
@property (strong) BTimestamp* startTimestamp;
@property (strong) BTimestamp* stopTimestamp;
@end

@implementation BTimespan

- (BOOL) hasStartTimestamp {
  return !!hasStartTimestamp_;
}
- (void) setHasStartTimestamp:(BOOL) _value_ {
  hasStartTimestamp_ = !!_value_;
}
@synthesize startTimestamp;
- (BOOL) hasStopTimestamp {
  return !!hasStopTimestamp_;
}
- (void) setHasStopTimestamp:(BOOL) _value_ {
  hasStopTimestamp_ = !!_value_;
}
@synthesize stopTimestamp;
- (instancetype) init {
  if ((self = [super init])) {
    self.startTimestamp = [BTimestamp defaultInstance];
    self.stopTimestamp = [BTimestamp defaultInstance];
  }
  return self;
}
static BTimespan* defaultBTimespanInstance = nil;
+ (void) initialize {
  if (self == [BTimespan class]) {
    defaultBTimespanInstance = [[BTimespan alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBTimespanInstance;
}
- (instancetype) defaultInstance {
  return defaultBTimespanInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasStartTimestamp) {
    [output writeMessage:1 value:self.startTimestamp];
  }
  if (self.hasStopTimestamp) {
    [output writeMessage:2 value:self.stopTimestamp];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasStartTimestamp) {
    size_ += computeMessageSize(1, self.startTimestamp);
  }
  if (self.hasStopTimestamp) {
    size_ += computeMessageSize(2, self.stopTimestamp);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BTimespan*) parseFromData:(NSData*) data {
  return (BTimespan*)[[[BTimespan builder] mergeFromData:data] build];
}
+ (BTimespan*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BTimespan*)[[[BTimespan builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BTimespan*) parseFromInputStream:(NSInputStream*) input {
  return (BTimespan*)[[[BTimespan builder] mergeFromInputStream:input] build];
}
+ (BTimespan*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BTimespan*)[[[BTimespan builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BTimespan*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BTimespan*)[[[BTimespan builder] mergeFromCodedInputStream:input] build];
}
+ (BTimespan*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BTimespan*)[[[BTimespan builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BTimespanBuilder*) builder {
  return [[BTimespanBuilder alloc] init];
}
+ (BTimespanBuilder*) builderWithPrototype:(BTimespan*) prototype {
  return [[BTimespan builder] mergeFrom:prototype];
}
- (BTimespanBuilder*) builder {
  return [BTimespan builder];
}
- (BTimespanBuilder*) toBuilder {
  return [BTimespan builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasStartTimestamp) {
    [output appendFormat:@"%@%@ {\n", indent, @"startTimestamp"];
    [self.startTimestamp writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  if (self.hasStopTimestamp) {
    [output appendFormat:@"%@%@ {\n", indent, @"stopTimestamp"];
    [self.stopTimestamp writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasStartTimestamp) {
   NSMutableDictionary *messageDictionary = [NSMutableDictionary dictionary]; 
   [self.startTimestamp storeInDictionary:messageDictionary];
   [dictionary setObject:[NSDictionary dictionaryWithDictionary:messageDictionary] forKey:@"startTimestamp"];
  }
  if (self.hasStopTimestamp) {
   NSMutableDictionary *messageDictionary = [NSMutableDictionary dictionary]; 
   [self.stopTimestamp storeInDictionary:messageDictionary];
   [dictionary setObject:[NSDictionary dictionaryWithDictionary:messageDictionary] forKey:@"stopTimestamp"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BTimespan class]]) {
    return NO;
  }
  BTimespan *otherMessage = other;
  return
      self.hasStartTimestamp == otherMessage.hasStartTimestamp &&
      (!self.hasStartTimestamp || [self.startTimestamp isEqual:otherMessage.startTimestamp]) &&
      self.hasStopTimestamp == otherMessage.hasStopTimestamp &&
      (!self.hasStopTimestamp || [self.stopTimestamp isEqual:otherMessage.stopTimestamp]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasStartTimestamp) {
    hashCode = hashCode * 31 + [self.startTimestamp hash];
  }
  if (self.hasStopTimestamp) {
    hashCode = hashCode * 31 + [self.stopTimestamp hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BTimespanBuilder()
@property (strong) BTimespan* resultTimespan;
@end

@implementation BTimespanBuilder
@synthesize resultTimespan;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultTimespan = [[BTimespan alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultTimespan;
}
- (BTimespanBuilder*) clear {
  self.resultTimespan = [[BTimespan alloc] init];
  return self;
}
- (BTimespanBuilder*) clone {
  return [BTimespan builderWithPrototype:resultTimespan];
}
- (BTimespan*) defaultInstance {
  return [BTimespan defaultInstance];
}
- (BTimespan*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BTimespan*) buildPartial {
  BTimespan* returnMe = resultTimespan;
  self.resultTimespan = nil;
  return returnMe;
}
- (BTimespanBuilder*) mergeFrom:(BTimespan*) other {
  if (other == [BTimespan defaultInstance]) {
    return self;
  }
  if (other.hasStartTimestamp) {
    [self mergeStartTimestamp:other.startTimestamp];
  }
  if (other.hasStopTimestamp) {
    [self mergeStopTimestamp:other.stopTimestamp];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BTimespanBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BTimespanBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        BTimestampBuilder* subBuilder = [BTimestamp builder];
        if (self.hasStartTimestamp) {
          [subBuilder mergeFrom:self.startTimestamp];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setStartTimestamp:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        BTimestampBuilder* subBuilder = [BTimestamp builder];
        if (self.hasStopTimestamp) {
          [subBuilder mergeFrom:self.stopTimestamp];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setStopTimestamp:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasStartTimestamp {
  return resultTimespan.hasStartTimestamp;
}
- (BTimestamp*) startTimestamp {
  return resultTimespan.startTimestamp;
}
- (BTimespanBuilder*) setStartTimestamp:(BTimestamp*) value {
  resultTimespan.hasStartTimestamp = YES;
  resultTimespan.startTimestamp = value;
  return self;
}
- (BTimespanBuilder*) setStartTimestampBuilder:(BTimestampBuilder*) builderForValue {
  return [self setStartTimestamp:[builderForValue build]];
}
- (BTimespanBuilder*) mergeStartTimestamp:(BTimestamp*) value {
  if (resultTimespan.hasStartTimestamp &&
      resultTimespan.startTimestamp != [BTimestamp defaultInstance]) {
    resultTimespan.startTimestamp =
      [[[BTimestamp builderWithPrototype:resultTimespan.startTimestamp] mergeFrom:value] buildPartial];
  } else {
    resultTimespan.startTimestamp = value;
  }
  resultTimespan.hasStartTimestamp = YES;
  return self;
}
- (BTimespanBuilder*) clearStartTimestamp {
  resultTimespan.hasStartTimestamp = NO;
  resultTimespan.startTimestamp = [BTimestamp defaultInstance];
  return self;
}
- (BOOL) hasStopTimestamp {
  return resultTimespan.hasStopTimestamp;
}
- (BTimestamp*) stopTimestamp {
  return resultTimespan.stopTimestamp;
}
- (BTimespanBuilder*) setStopTimestamp:(BTimestamp*) value {
  resultTimespan.hasStopTimestamp = YES;
  resultTimespan.stopTimestamp = value;
  return self;
}
- (BTimespanBuilder*) setStopTimestampBuilder:(BTimestampBuilder*) builderForValue {
  return [self setStopTimestamp:[builderForValue build]];
}
- (BTimespanBuilder*) mergeStopTimestamp:(BTimestamp*) value {
  if (resultTimespan.hasStopTimestamp &&
      resultTimespan.stopTimestamp != [BTimestamp defaultInstance]) {
    resultTimespan.stopTimestamp =
      [[[BTimestamp builderWithPrototype:resultTimespan.stopTimestamp] mergeFrom:value] buildPartial];
  } else {
    resultTimespan.stopTimestamp = value;
  }
  resultTimespan.hasStopTimestamp = YES;
  return self;
}
- (BTimespanBuilder*) clearStopTimestamp {
  resultTimespan.hasStopTimestamp = NO;
  resultTimespan.stopTimestamp = [BTimestamp defaultInstance];
  return self;
}
@end

@interface BPoint ()
@property Float64 x;
@property Float64 y;
@end

@implementation BPoint

- (BOOL) hasX {
  return !!hasX_;
}
- (void) setHasX:(BOOL) _value_ {
  hasX_ = !!_value_;
}
@synthesize x;
- (BOOL) hasY {
  return !!hasY_;
}
- (void) setHasY:(BOOL) _value_ {
  hasY_ = !!_value_;
}
@synthesize y;
- (instancetype) init {
  if ((self = [super init])) {
    self.x = 0;
    self.y = 0;
  }
  return self;
}
static BPoint* defaultBPointInstance = nil;
+ (void) initialize {
  if (self == [BPoint class]) {
    defaultBPointInstance = [[BPoint alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBPointInstance;
}
- (instancetype) defaultInstance {
  return defaultBPointInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasX) {
    [output writeDouble:1 value:self.x];
  }
  if (self.hasY) {
    [output writeDouble:2 value:self.y];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasX) {
    size_ += computeDoubleSize(1, self.x);
  }
  if (self.hasY) {
    size_ += computeDoubleSize(2, self.y);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BPoint*) parseFromData:(NSData*) data {
  return (BPoint*)[[[BPoint builder] mergeFromData:data] build];
}
+ (BPoint*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BPoint*)[[[BPoint builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BPoint*) parseFromInputStream:(NSInputStream*) input {
  return (BPoint*)[[[BPoint builder] mergeFromInputStream:input] build];
}
+ (BPoint*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BPoint*)[[[BPoint builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BPoint*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BPoint*)[[[BPoint builder] mergeFromCodedInputStream:input] build];
}
+ (BPoint*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BPoint*)[[[BPoint builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BPointBuilder*) builder {
  return [[BPointBuilder alloc] init];
}
+ (BPointBuilder*) builderWithPrototype:(BPoint*) prototype {
  return [[BPoint builder] mergeFrom:prototype];
}
- (BPointBuilder*) builder {
  return [BPoint builder];
}
- (BPointBuilder*) toBuilder {
  return [BPoint builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasX) {
    [output appendFormat:@"%@%@: %@\n", indent, @"x", [NSNumber numberWithDouble:self.x]];
  }
  if (self.hasY) {
    [output appendFormat:@"%@%@: %@\n", indent, @"y", [NSNumber numberWithDouble:self.y]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasX) {
    [dictionary setObject: [NSNumber numberWithDouble:self.x] forKey: @"x"];
  }
  if (self.hasY) {
    [dictionary setObject: [NSNumber numberWithDouble:self.y] forKey: @"y"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BPoint class]]) {
    return NO;
  }
  BPoint *otherMessage = other;
  return
      self.hasX == otherMessage.hasX &&
      (!self.hasX || self.x == otherMessage.x) &&
      self.hasY == otherMessage.hasY &&
      (!self.hasY || self.y == otherMessage.y) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasX) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.x] hash];
  }
  if (self.hasY) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.y] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BPointBuilder()
@property (strong) BPoint* resultPoint;
@end

@implementation BPointBuilder
@synthesize resultPoint;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultPoint = [[BPoint alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultPoint;
}
- (BPointBuilder*) clear {
  self.resultPoint = [[BPoint alloc] init];
  return self;
}
- (BPointBuilder*) clone {
  return [BPoint builderWithPrototype:resultPoint];
}
- (BPoint*) defaultInstance {
  return [BPoint defaultInstance];
}
- (BPoint*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BPoint*) buildPartial {
  BPoint* returnMe = resultPoint;
  self.resultPoint = nil;
  return returnMe;
}
- (BPointBuilder*) mergeFrom:(BPoint*) other {
  if (other == [BPoint defaultInstance]) {
    return self;
  }
  if (other.hasX) {
    [self setX:other.x];
  }
  if (other.hasY) {
    [self setY:other.y];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BPointBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BPointBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 9: {
        [self setX:[input readDouble]];
        break;
      }
      case 17: {
        [self setY:[input readDouble]];
        break;
      }
    }
  }
}
- (BOOL) hasX {
  return resultPoint.hasX;
}
- (Float64) x {
  return resultPoint.x;
}
- (BPointBuilder*) setX:(Float64) value {
  resultPoint.hasX = YES;
  resultPoint.x = value;
  return self;
}
- (BPointBuilder*) clearX {
  resultPoint.hasX = NO;
  resultPoint.x = 0;
  return self;
}
- (BOOL) hasY {
  return resultPoint.hasY;
}
- (Float64) y {
  return resultPoint.y;
}
- (BPointBuilder*) setY:(Float64) value {
  resultPoint.hasY = YES;
  resultPoint.y = value;
  return self;
}
- (BPointBuilder*) clearY {
  resultPoint.hasY = NO;
  resultPoint.y = 0;
  return self;
}
@end

@interface BSize ()
@property Float64 width;
@property Float64 height;
@end

@implementation BSize

- (BOOL) hasWidth {
  return !!hasWidth_;
}
- (void) setHasWidth:(BOOL) _value_ {
  hasWidth_ = !!_value_;
}
@synthesize width;
- (BOOL) hasHeight {
  return !!hasHeight_;
}
- (void) setHasHeight:(BOOL) _value_ {
  hasHeight_ = !!_value_;
}
@synthesize height;
- (instancetype) init {
  if ((self = [super init])) {
    self.width = 0;
    self.height = 0;
  }
  return self;
}
static BSize* defaultBSizeInstance = nil;
+ (void) initialize {
  if (self == [BSize class]) {
    defaultBSizeInstance = [[BSize alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBSizeInstance;
}
- (instancetype) defaultInstance {
  return defaultBSizeInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasWidth) {
    [output writeDouble:1 value:self.width];
  }
  if (self.hasHeight) {
    [output writeDouble:2 value:self.height];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasWidth) {
    size_ += computeDoubleSize(1, self.width);
  }
  if (self.hasHeight) {
    size_ += computeDoubleSize(2, self.height);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BSize*) parseFromData:(NSData*) data {
  return (BSize*)[[[BSize builder] mergeFromData:data] build];
}
+ (BSize*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BSize*)[[[BSize builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BSize*) parseFromInputStream:(NSInputStream*) input {
  return (BSize*)[[[BSize builder] mergeFromInputStream:input] build];
}
+ (BSize*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BSize*)[[[BSize builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BSize*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BSize*)[[[BSize builder] mergeFromCodedInputStream:input] build];
}
+ (BSize*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BSize*)[[[BSize builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BSizeBuilder*) builder {
  return [[BSizeBuilder alloc] init];
}
+ (BSizeBuilder*) builderWithPrototype:(BSize*) prototype {
  return [[BSize builder] mergeFrom:prototype];
}
- (BSizeBuilder*) builder {
  return [BSize builder];
}
- (BSizeBuilder*) toBuilder {
  return [BSize builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasWidth) {
    [output appendFormat:@"%@%@: %@\n", indent, @"width", [NSNumber numberWithDouble:self.width]];
  }
  if (self.hasHeight) {
    [output appendFormat:@"%@%@: %@\n", indent, @"height", [NSNumber numberWithDouble:self.height]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasWidth) {
    [dictionary setObject: [NSNumber numberWithDouble:self.width] forKey: @"width"];
  }
  if (self.hasHeight) {
    [dictionary setObject: [NSNumber numberWithDouble:self.height] forKey: @"height"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BSize class]]) {
    return NO;
  }
  BSize *otherMessage = other;
  return
      self.hasWidth == otherMessage.hasWidth &&
      (!self.hasWidth || self.width == otherMessage.width) &&
      self.hasHeight == otherMessage.hasHeight &&
      (!self.hasHeight || self.height == otherMessage.height) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasWidth) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.width] hash];
  }
  if (self.hasHeight) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.height] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BSizeBuilder()
@property (strong) BSize* resultSize;
@end

@implementation BSizeBuilder
@synthesize resultSize;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultSize = [[BSize alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultSize;
}
- (BSizeBuilder*) clear {
  self.resultSize = [[BSize alloc] init];
  return self;
}
- (BSizeBuilder*) clone {
  return [BSize builderWithPrototype:resultSize];
}
- (BSize*) defaultInstance {
  return [BSize defaultInstance];
}
- (BSize*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BSize*) buildPartial {
  BSize* returnMe = resultSize;
  self.resultSize = nil;
  return returnMe;
}
- (BSizeBuilder*) mergeFrom:(BSize*) other {
  if (other == [BSize defaultInstance]) {
    return self;
  }
  if (other.hasWidth) {
    [self setWidth:other.width];
  }
  if (other.hasHeight) {
    [self setHeight:other.height];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BSizeBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BSizeBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 9: {
        [self setWidth:[input readDouble]];
        break;
      }
      case 17: {
        [self setHeight:[input readDouble]];
        break;
      }
    }
  }
}
- (BOOL) hasWidth {
  return resultSize.hasWidth;
}
- (Float64) width {
  return resultSize.width;
}
- (BSizeBuilder*) setWidth:(Float64) value {
  resultSize.hasWidth = YES;
  resultSize.width = value;
  return self;
}
- (BSizeBuilder*) clearWidth {
  resultSize.hasWidth = NO;
  resultSize.width = 0;
  return self;
}
- (BOOL) hasHeight {
  return resultSize.hasHeight;
}
- (Float64) height {
  return resultSize.height;
}
- (BSizeBuilder*) setHeight:(Float64) value {
  resultSize.hasHeight = YES;
  resultSize.height = value;
  return self;
}
- (BSizeBuilder*) clearHeight {
  resultSize.hasHeight = NO;
  resultSize.height = 0;
  return self;
}
@end

@interface BCoordinate ()
@property Float64 latitude;
@property Float64 longitude;
@end

@implementation BCoordinate

- (BOOL) hasLatitude {
  return !!hasLatitude_;
}
- (void) setHasLatitude:(BOOL) _value_ {
  hasLatitude_ = !!_value_;
}
@synthesize latitude;
- (BOOL) hasLongitude {
  return !!hasLongitude_;
}
- (void) setHasLongitude:(BOOL) _value_ {
  hasLongitude_ = !!_value_;
}
@synthesize longitude;
- (instancetype) init {
  if ((self = [super init])) {
    self.latitude = -360;
    self.longitude = -360;
  }
  return self;
}
static BCoordinate* defaultBCoordinateInstance = nil;
+ (void) initialize {
  if (self == [BCoordinate class]) {
    defaultBCoordinateInstance = [[BCoordinate alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBCoordinateInstance;
}
- (instancetype) defaultInstance {
  return defaultBCoordinateInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasLatitude) {
    [output writeDouble:1 value:self.latitude];
  }
  if (self.hasLongitude) {
    [output writeDouble:2 value:self.longitude];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasLatitude) {
    size_ += computeDoubleSize(1, self.latitude);
  }
  if (self.hasLongitude) {
    size_ += computeDoubleSize(2, self.longitude);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BCoordinate*) parseFromData:(NSData*) data {
  return (BCoordinate*)[[[BCoordinate builder] mergeFromData:data] build];
}
+ (BCoordinate*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinate*)[[[BCoordinate builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BCoordinate*) parseFromInputStream:(NSInputStream*) input {
  return (BCoordinate*)[[[BCoordinate builder] mergeFromInputStream:input] build];
}
+ (BCoordinate*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinate*)[[[BCoordinate builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BCoordinate*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BCoordinate*)[[[BCoordinate builder] mergeFromCodedInputStream:input] build];
}
+ (BCoordinate*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinate*)[[[BCoordinate builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BCoordinateBuilder*) builder {
  return [[BCoordinateBuilder alloc] init];
}
+ (BCoordinateBuilder*) builderWithPrototype:(BCoordinate*) prototype {
  return [[BCoordinate builder] mergeFrom:prototype];
}
- (BCoordinateBuilder*) builder {
  return [BCoordinate builder];
}
- (BCoordinateBuilder*) toBuilder {
  return [BCoordinate builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasLatitude) {
    [output appendFormat:@"%@%@: %@\n", indent, @"latitude", [NSNumber numberWithDouble:self.latitude]];
  }
  if (self.hasLongitude) {
    [output appendFormat:@"%@%@: %@\n", indent, @"longitude", [NSNumber numberWithDouble:self.longitude]];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasLatitude) {
    [dictionary setObject: [NSNumber numberWithDouble:self.latitude] forKey: @"latitude"];
  }
  if (self.hasLongitude) {
    [dictionary setObject: [NSNumber numberWithDouble:self.longitude] forKey: @"longitude"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BCoordinate class]]) {
    return NO;
  }
  BCoordinate *otherMessage = other;
  return
      self.hasLatitude == otherMessage.hasLatitude &&
      (!self.hasLatitude || self.latitude == otherMessage.latitude) &&
      self.hasLongitude == otherMessage.hasLongitude &&
      (!self.hasLongitude || self.longitude == otherMessage.longitude) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasLatitude) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.latitude] hash];
  }
  if (self.hasLongitude) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.longitude] hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BCoordinateBuilder()
@property (strong) BCoordinate* resultCoordinate;
@end

@implementation BCoordinateBuilder
@synthesize resultCoordinate;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultCoordinate = [[BCoordinate alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultCoordinate;
}
- (BCoordinateBuilder*) clear {
  self.resultCoordinate = [[BCoordinate alloc] init];
  return self;
}
- (BCoordinateBuilder*) clone {
  return [BCoordinate builderWithPrototype:resultCoordinate];
}
- (BCoordinate*) defaultInstance {
  return [BCoordinate defaultInstance];
}
- (BCoordinate*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BCoordinate*) buildPartial {
  BCoordinate* returnMe = resultCoordinate;
  self.resultCoordinate = nil;
  return returnMe;
}
- (BCoordinateBuilder*) mergeFrom:(BCoordinate*) other {
  if (other == [BCoordinate defaultInstance]) {
    return self;
  }
  if (other.hasLatitude) {
    [self setLatitude:other.latitude];
  }
  if (other.hasLongitude) {
    [self setLongitude:other.longitude];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BCoordinateBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BCoordinateBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 9: {
        [self setLatitude:[input readDouble]];
        break;
      }
      case 17: {
        [self setLongitude:[input readDouble]];
        break;
      }
    }
  }
}
- (BOOL) hasLatitude {
  return resultCoordinate.hasLatitude;
}
- (Float64) latitude {
  return resultCoordinate.latitude;
}
- (BCoordinateBuilder*) setLatitude:(Float64) value {
  resultCoordinate.hasLatitude = YES;
  resultCoordinate.latitude = value;
  return self;
}
- (BCoordinateBuilder*) clearLatitude {
  resultCoordinate.hasLatitude = NO;
  resultCoordinate.latitude = -360;
  return self;
}
- (BOOL) hasLongitude {
  return resultCoordinate.hasLongitude;
}
- (Float64) longitude {
  return resultCoordinate.longitude;
}
- (BCoordinateBuilder*) setLongitude:(Float64) value {
  resultCoordinate.hasLongitude = YES;
  resultCoordinate.longitude = value;
  return self;
}
- (BCoordinateBuilder*) clearLongitude {
  resultCoordinate.hasLongitude = NO;
  resultCoordinate.longitude = -360;
  return self;
}
@end

@interface BCoordinateRegion ()
@property (strong) BCoordinate* center;
@property (strong) BCoordinate* span;
@end

@implementation BCoordinateRegion

- (BOOL) hasCenter {
  return !!hasCenter_;
}
- (void) setHasCenter:(BOOL) _value_ {
  hasCenter_ = !!_value_;
}
@synthesize center;
- (BOOL) hasSpan {
  return !!hasSpan_;
}
- (void) setHasSpan:(BOOL) _value_ {
  hasSpan_ = !!_value_;
}
@synthesize span;
- (instancetype) init {
  if ((self = [super init])) {
    self.center = [BCoordinate defaultInstance];
    self.span = [BCoordinate defaultInstance];
  }
  return self;
}
static BCoordinateRegion* defaultBCoordinateRegionInstance = nil;
+ (void) initialize {
  if (self == [BCoordinateRegion class]) {
    defaultBCoordinateRegionInstance = [[BCoordinateRegion alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBCoordinateRegionInstance;
}
- (instancetype) defaultInstance {
  return defaultBCoordinateRegionInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasCenter) {
    [output writeMessage:1 value:self.center];
  }
  if (self.hasSpan) {
    [output writeMessage:2 value:self.span];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasCenter) {
    size_ += computeMessageSize(1, self.center);
  }
  if (self.hasSpan) {
    size_ += computeMessageSize(2, self.span);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BCoordinateRegion*) parseFromData:(NSData*) data {
  return (BCoordinateRegion*)[[[BCoordinateRegion builder] mergeFromData:data] build];
}
+ (BCoordinateRegion*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinateRegion*)[[[BCoordinateRegion builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BCoordinateRegion*) parseFromInputStream:(NSInputStream*) input {
  return (BCoordinateRegion*)[[[BCoordinateRegion builder] mergeFromInputStream:input] build];
}
+ (BCoordinateRegion*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinateRegion*)[[[BCoordinateRegion builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BCoordinateRegion*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BCoordinateRegion*)[[[BCoordinateRegion builder] mergeFromCodedInputStream:input] build];
}
+ (BCoordinateRegion*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinateRegion*)[[[BCoordinateRegion builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BCoordinateRegionBuilder*) builder {
  return [[BCoordinateRegionBuilder alloc] init];
}
+ (BCoordinateRegionBuilder*) builderWithPrototype:(BCoordinateRegion*) prototype {
  return [[BCoordinateRegion builder] mergeFrom:prototype];
}
- (BCoordinateRegionBuilder*) builder {
  return [BCoordinateRegion builder];
}
- (BCoordinateRegionBuilder*) toBuilder {
  return [BCoordinateRegion builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasCenter) {
    [output appendFormat:@"%@%@ {\n", indent, @"center"];
    [self.center writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  if (self.hasSpan) {
    [output appendFormat:@"%@%@ {\n", indent, @"span"];
    [self.span writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasCenter) {
   NSMutableDictionary *messageDictionary = [NSMutableDictionary dictionary]; 
   [self.center storeInDictionary:messageDictionary];
   [dictionary setObject:[NSDictionary dictionaryWithDictionary:messageDictionary] forKey:@"center"];
  }
  if (self.hasSpan) {
   NSMutableDictionary *messageDictionary = [NSMutableDictionary dictionary]; 
   [self.span storeInDictionary:messageDictionary];
   [dictionary setObject:[NSDictionary dictionaryWithDictionary:messageDictionary] forKey:@"span"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BCoordinateRegion class]]) {
    return NO;
  }
  BCoordinateRegion *otherMessage = other;
  return
      self.hasCenter == otherMessage.hasCenter &&
      (!self.hasCenter || [self.center isEqual:otherMessage.center]) &&
      self.hasSpan == otherMessage.hasSpan &&
      (!self.hasSpan || [self.span isEqual:otherMessage.span]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasCenter) {
    hashCode = hashCode * 31 + [self.center hash];
  }
  if (self.hasSpan) {
    hashCode = hashCode * 31 + [self.span hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BCoordinateRegionBuilder()
@property (strong) BCoordinateRegion* resultCoordinateRegion;
@end

@implementation BCoordinateRegionBuilder
@synthesize resultCoordinateRegion;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultCoordinateRegion = [[BCoordinateRegion alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultCoordinateRegion;
}
- (BCoordinateRegionBuilder*) clear {
  self.resultCoordinateRegion = [[BCoordinateRegion alloc] init];
  return self;
}
- (BCoordinateRegionBuilder*) clone {
  return [BCoordinateRegion builderWithPrototype:resultCoordinateRegion];
}
- (BCoordinateRegion*) defaultInstance {
  return [BCoordinateRegion defaultInstance];
}
- (BCoordinateRegion*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BCoordinateRegion*) buildPartial {
  BCoordinateRegion* returnMe = resultCoordinateRegion;
  self.resultCoordinateRegion = nil;
  return returnMe;
}
- (BCoordinateRegionBuilder*) mergeFrom:(BCoordinateRegion*) other {
  if (other == [BCoordinateRegion defaultInstance]) {
    return self;
  }
  if (other.hasCenter) {
    [self mergeCenter:other.center];
  }
  if (other.hasSpan) {
    [self mergeSpan:other.span];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BCoordinateRegionBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BCoordinateRegionBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        BCoordinateBuilder* subBuilder = [BCoordinate builder];
        if (self.hasCenter) {
          [subBuilder mergeFrom:self.center];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setCenter:[subBuilder buildPartial]];
        break;
      }
      case 18: {
        BCoordinateBuilder* subBuilder = [BCoordinate builder];
        if (self.hasSpan) {
          [subBuilder mergeFrom:self.span];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setSpan:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasCenter {
  return resultCoordinateRegion.hasCenter;
}
- (BCoordinate*) center {
  return resultCoordinateRegion.center;
}
- (BCoordinateRegionBuilder*) setCenter:(BCoordinate*) value {
  resultCoordinateRegion.hasCenter = YES;
  resultCoordinateRegion.center = value;
  return self;
}
- (BCoordinateRegionBuilder*) setCenterBuilder:(BCoordinateBuilder*) builderForValue {
  return [self setCenter:[builderForValue build]];
}
- (BCoordinateRegionBuilder*) mergeCenter:(BCoordinate*) value {
  if (resultCoordinateRegion.hasCenter &&
      resultCoordinateRegion.center != [BCoordinate defaultInstance]) {
    resultCoordinateRegion.center =
      [[[BCoordinate builderWithPrototype:resultCoordinateRegion.center] mergeFrom:value] buildPartial];
  } else {
    resultCoordinateRegion.center = value;
  }
  resultCoordinateRegion.hasCenter = YES;
  return self;
}
- (BCoordinateRegionBuilder*) clearCenter {
  resultCoordinateRegion.hasCenter = NO;
  resultCoordinateRegion.center = [BCoordinate defaultInstance];
  return self;
}
- (BOOL) hasSpan {
  return resultCoordinateRegion.hasSpan;
}
- (BCoordinate*) span {
  return resultCoordinateRegion.span;
}
- (BCoordinateRegionBuilder*) setSpan:(BCoordinate*) value {
  resultCoordinateRegion.hasSpan = YES;
  resultCoordinateRegion.span = value;
  return self;
}
- (BCoordinateRegionBuilder*) setSpanBuilder:(BCoordinateBuilder*) builderForValue {
  return [self setSpan:[builderForValue build]];
}
- (BCoordinateRegionBuilder*) mergeSpan:(BCoordinate*) value {
  if (resultCoordinateRegion.hasSpan &&
      resultCoordinateRegion.span != [BCoordinate defaultInstance]) {
    resultCoordinateRegion.span =
      [[[BCoordinate builderWithPrototype:resultCoordinateRegion.span] mergeFrom:value] buildPartial];
  } else {
    resultCoordinateRegion.span = value;
  }
  resultCoordinateRegion.hasSpan = YES;
  return self;
}
- (BCoordinateRegionBuilder*) clearSpan {
  resultCoordinateRegion.hasSpan = NO;
  resultCoordinateRegion.span = [BCoordinate defaultInstance];
  return self;
}
@end

@interface BCoordinatePolygon ()
@property (strong) NSMutableArray<BCoordinate*> * pointsArray;
@end

@implementation BCoordinatePolygon

@synthesize pointsArray;
@dynamic points;
- (instancetype) init {
  if ((self = [super init])) {
  }
  return self;
}
static BCoordinatePolygon* defaultBCoordinatePolygonInstance = nil;
+ (void) initialize {
  if (self == [BCoordinatePolygon class]) {
    defaultBCoordinatePolygonInstance = [[BCoordinatePolygon alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBCoordinatePolygonInstance;
}
- (instancetype) defaultInstance {
  return defaultBCoordinatePolygonInstance;
}
- (NSArray<BCoordinate*> *)points {
  return pointsArray;
}
- (BCoordinate*)pointsAtIndex:(NSUInteger)index {
  return [pointsArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  [self.pointsArray enumerateObjectsUsingBlock:^(BCoordinate *element, NSUInteger idx, BOOL *stop) {
    [output writeMessage:1 value:element];
  }];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  [self.pointsArray enumerateObjectsUsingBlock:^(BCoordinate *element, NSUInteger idx, BOOL *stop) {
    size_ += computeMessageSize(1, element);
  }];
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BCoordinatePolygon*) parseFromData:(NSData*) data {
  return (BCoordinatePolygon*)[[[BCoordinatePolygon builder] mergeFromData:data] build];
}
+ (BCoordinatePolygon*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinatePolygon*)[[[BCoordinatePolygon builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BCoordinatePolygon*) parseFromInputStream:(NSInputStream*) input {
  return (BCoordinatePolygon*)[[[BCoordinatePolygon builder] mergeFromInputStream:input] build];
}
+ (BCoordinatePolygon*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinatePolygon*)[[[BCoordinatePolygon builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BCoordinatePolygon*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BCoordinatePolygon*)[[[BCoordinatePolygon builder] mergeFromCodedInputStream:input] build];
}
+ (BCoordinatePolygon*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BCoordinatePolygon*)[[[BCoordinatePolygon builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BCoordinatePolygonBuilder*) builder {
  return [[BCoordinatePolygonBuilder alloc] init];
}
+ (BCoordinatePolygonBuilder*) builderWithPrototype:(BCoordinatePolygon*) prototype {
  return [[BCoordinatePolygon builder] mergeFrom:prototype];
}
- (BCoordinatePolygonBuilder*) builder {
  return [BCoordinatePolygon builder];
}
- (BCoordinatePolygonBuilder*) toBuilder {
  return [BCoordinatePolygon builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  [self.pointsArray enumerateObjectsUsingBlock:^(BCoordinate *element, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@ {\n", indent, @"points"];
    [element writeDescriptionTo:output
                     withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  for (BCoordinate* element in self.pointsArray) {
    NSMutableDictionary *elementDictionary = [NSMutableDictionary dictionary];
    [element storeInDictionary:elementDictionary];
    [dictionary setObject:[NSDictionary dictionaryWithDictionary:elementDictionary] forKey:@"points"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BCoordinatePolygon class]]) {
    return NO;
  }
  BCoordinatePolygon *otherMessage = other;
  return
      [self.pointsArray isEqualToArray:otherMessage.pointsArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  [self.pointsArray enumerateObjectsUsingBlock:^(BCoordinate *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BCoordinatePolygonBuilder()
@property (strong) BCoordinatePolygon* resultCoordinatePolygon;
@end

@implementation BCoordinatePolygonBuilder
@synthesize resultCoordinatePolygon;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultCoordinatePolygon = [[BCoordinatePolygon alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultCoordinatePolygon;
}
- (BCoordinatePolygonBuilder*) clear {
  self.resultCoordinatePolygon = [[BCoordinatePolygon alloc] init];
  return self;
}
- (BCoordinatePolygonBuilder*) clone {
  return [BCoordinatePolygon builderWithPrototype:resultCoordinatePolygon];
}
- (BCoordinatePolygon*) defaultInstance {
  return [BCoordinatePolygon defaultInstance];
}
- (BCoordinatePolygon*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BCoordinatePolygon*) buildPartial {
  BCoordinatePolygon* returnMe = resultCoordinatePolygon;
  self.resultCoordinatePolygon = nil;
  return returnMe;
}
- (BCoordinatePolygonBuilder*) mergeFrom:(BCoordinatePolygon*) other {
  if (other == [BCoordinatePolygon defaultInstance]) {
    return self;
  }
  if (other.pointsArray.count > 0) {
    if (resultCoordinatePolygon.pointsArray == nil) {
      resultCoordinatePolygon.pointsArray = [[NSMutableArray alloc] initWithArray:other.pointsArray];
    } else {
      [resultCoordinatePolygon.pointsArray addObjectsFromArray:other.pointsArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BCoordinatePolygonBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BCoordinatePolygonBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        BCoordinateBuilder* subBuilder = [BCoordinate builder];
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self addPoints:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (NSMutableArray<BCoordinate*> *)points {
  return resultCoordinatePolygon.pointsArray;
}
- (BCoordinate*)pointsAtIndex:(NSUInteger)index {
  return [resultCoordinatePolygon pointsAtIndex:index];
}
- (BCoordinatePolygonBuilder *)addPoints:(BCoordinate*)value {
  if (resultCoordinatePolygon.pointsArray == nil) {
    resultCoordinatePolygon.pointsArray = [[NSMutableArray alloc]init];
  }
  [resultCoordinatePolygon.pointsArray addObject:value];
  return self;
}
- (BCoordinatePolygonBuilder *)setPointsArray:(NSArray<BCoordinate*> *)array {
  resultCoordinatePolygon.pointsArray = [[NSMutableArray alloc]initWithArray:array];
  return self;
}
- (BCoordinatePolygonBuilder *)clearPoints {
  resultCoordinatePolygon.pointsArray = nil;
  return self;
}
@end

@interface BLocation ()
@property (strong) BCoordinate* coordinate;
@property Float64 altitude;
@property Float64 speed;
@property Float64 course;
@property (strong) BTimestamp* timestamp;
@property (strong) NSString* placename;
@end

@implementation BLocation

- (BOOL) hasCoordinate {
  return !!hasCoordinate_;
}
- (void) setHasCoordinate:(BOOL) _value_ {
  hasCoordinate_ = !!_value_;
}
@synthesize coordinate;
- (BOOL) hasAltitude {
  return !!hasAltitude_;
}
- (void) setHasAltitude:(BOOL) _value_ {
  hasAltitude_ = !!_value_;
}
@synthesize altitude;
- (BOOL) hasSpeed {
  return !!hasSpeed_;
}
- (void) setHasSpeed:(BOOL) _value_ {
  hasSpeed_ = !!_value_;
}
@synthesize speed;
- (BOOL) hasCourse {
  return !!hasCourse_;
}
- (void) setHasCourse:(BOOL) _value_ {
  hasCourse_ = !!_value_;
}
@synthesize course;
- (BOOL) hasTimestamp {
  return !!hasTimestamp_;
}
- (void) setHasTimestamp:(BOOL) _value_ {
  hasTimestamp_ = !!_value_;
}
@synthesize timestamp;
- (BOOL) hasPlacename {
  return !!hasPlacename_;
}
- (void) setHasPlacename:(BOOL) _value_ {
  hasPlacename_ = !!_value_;
}
@synthesize placename;
- (instancetype) init {
  if ((self = [super init])) {
    self.coordinate = [BCoordinate defaultInstance];
    self.altitude = 0;
    self.speed = 0;
    self.course = 0;
    self.timestamp = [BTimestamp defaultInstance];
    self.placename = @"";
  }
  return self;
}
static BLocation* defaultBLocationInstance = nil;
+ (void) initialize {
  if (self == [BLocation class]) {
    defaultBLocationInstance = [[BLocation alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBLocationInstance;
}
- (instancetype) defaultInstance {
  return defaultBLocationInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasCoordinate) {
    [output writeMessage:1 value:self.coordinate];
  }
  if (self.hasAltitude) {
    [output writeDouble:2 value:self.altitude];
  }
  if (self.hasSpeed) {
    [output writeDouble:3 value:self.speed];
  }
  if (self.hasCourse) {
    [output writeDouble:4 value:self.course];
  }
  if (self.hasTimestamp) {
    [output writeMessage:5 value:self.timestamp];
  }
  if (self.hasPlacename) {
    [output writeString:6 value:self.placename];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasCoordinate) {
    size_ += computeMessageSize(1, self.coordinate);
  }
  if (self.hasAltitude) {
    size_ += computeDoubleSize(2, self.altitude);
  }
  if (self.hasSpeed) {
    size_ += computeDoubleSize(3, self.speed);
  }
  if (self.hasCourse) {
    size_ += computeDoubleSize(4, self.course);
  }
  if (self.hasTimestamp) {
    size_ += computeMessageSize(5, self.timestamp);
  }
  if (self.hasPlacename) {
    size_ += computeStringSize(6, self.placename);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BLocation*) parseFromData:(NSData*) data {
  return (BLocation*)[[[BLocation builder] mergeFromData:data] build];
}
+ (BLocation*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BLocation*)[[[BLocation builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BLocation*) parseFromInputStream:(NSInputStream*) input {
  return (BLocation*)[[[BLocation builder] mergeFromInputStream:input] build];
}
+ (BLocation*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BLocation*)[[[BLocation builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BLocation*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BLocation*)[[[BLocation builder] mergeFromCodedInputStream:input] build];
}
+ (BLocation*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BLocation*)[[[BLocation builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BLocationBuilder*) builder {
  return [[BLocationBuilder alloc] init];
}
+ (BLocationBuilder*) builderWithPrototype:(BLocation*) prototype {
  return [[BLocation builder] mergeFrom:prototype];
}
- (BLocationBuilder*) builder {
  return [BLocation builder];
}
- (BLocationBuilder*) toBuilder {
  return [BLocation builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasCoordinate) {
    [output appendFormat:@"%@%@ {\n", indent, @"coordinate"];
    [self.coordinate writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  if (self.hasAltitude) {
    [output appendFormat:@"%@%@: %@\n", indent, @"altitude", [NSNumber numberWithDouble:self.altitude]];
  }
  if (self.hasSpeed) {
    [output appendFormat:@"%@%@: %@\n", indent, @"speed", [NSNumber numberWithDouble:self.speed]];
  }
  if (self.hasCourse) {
    [output appendFormat:@"%@%@: %@\n", indent, @"course", [NSNumber numberWithDouble:self.course]];
  }
  if (self.hasTimestamp) {
    [output appendFormat:@"%@%@ {\n", indent, @"timestamp"];
    [self.timestamp writeDescriptionTo:output
                         withIndent:[NSString stringWithFormat:@"%@  ", indent]];
    [output appendFormat:@"%@}\n", indent];
  }
  if (self.hasPlacename) {
    [output appendFormat:@"%@%@: %@\n", indent, @"placename", self.placename];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasCoordinate) {
   NSMutableDictionary *messageDictionary = [NSMutableDictionary dictionary]; 
   [self.coordinate storeInDictionary:messageDictionary];
   [dictionary setObject:[NSDictionary dictionaryWithDictionary:messageDictionary] forKey:@"coordinate"];
  }
  if (self.hasAltitude) {
    [dictionary setObject: [NSNumber numberWithDouble:self.altitude] forKey: @"altitude"];
  }
  if (self.hasSpeed) {
    [dictionary setObject: [NSNumber numberWithDouble:self.speed] forKey: @"speed"];
  }
  if (self.hasCourse) {
    [dictionary setObject: [NSNumber numberWithDouble:self.course] forKey: @"course"];
  }
  if (self.hasTimestamp) {
   NSMutableDictionary *messageDictionary = [NSMutableDictionary dictionary]; 
   [self.timestamp storeInDictionary:messageDictionary];
   [dictionary setObject:[NSDictionary dictionaryWithDictionary:messageDictionary] forKey:@"timestamp"];
  }
  if (self.hasPlacename) {
    [dictionary setObject: self.placename forKey: @"placename"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BLocation class]]) {
    return NO;
  }
  BLocation *otherMessage = other;
  return
      self.hasCoordinate == otherMessage.hasCoordinate &&
      (!self.hasCoordinate || [self.coordinate isEqual:otherMessage.coordinate]) &&
      self.hasAltitude == otherMessage.hasAltitude &&
      (!self.hasAltitude || self.altitude == otherMessage.altitude) &&
      self.hasSpeed == otherMessage.hasSpeed &&
      (!self.hasSpeed || self.speed == otherMessage.speed) &&
      self.hasCourse == otherMessage.hasCourse &&
      (!self.hasCourse || self.course == otherMessage.course) &&
      self.hasTimestamp == otherMessage.hasTimestamp &&
      (!self.hasTimestamp || [self.timestamp isEqual:otherMessage.timestamp]) &&
      self.hasPlacename == otherMessage.hasPlacename &&
      (!self.hasPlacename || [self.placename isEqual:otherMessage.placename]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasCoordinate) {
    hashCode = hashCode * 31 + [self.coordinate hash];
  }
  if (self.hasAltitude) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.altitude] hash];
  }
  if (self.hasSpeed) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.speed] hash];
  }
  if (self.hasCourse) {
    hashCode = hashCode * 31 + [[NSNumber numberWithDouble:self.course] hash];
  }
  if (self.hasTimestamp) {
    hashCode = hashCode * 31 + [self.timestamp hash];
  }
  if (self.hasPlacename) {
    hashCode = hashCode * 31 + [self.placename hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BLocationBuilder()
@property (strong) BLocation* resultLocation;
@end

@implementation BLocationBuilder
@synthesize resultLocation;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultLocation = [[BLocation alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultLocation;
}
- (BLocationBuilder*) clear {
  self.resultLocation = [[BLocation alloc] init];
  return self;
}
- (BLocationBuilder*) clone {
  return [BLocation builderWithPrototype:resultLocation];
}
- (BLocation*) defaultInstance {
  return [BLocation defaultInstance];
}
- (BLocation*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BLocation*) buildPartial {
  BLocation* returnMe = resultLocation;
  self.resultLocation = nil;
  return returnMe;
}
- (BLocationBuilder*) mergeFrom:(BLocation*) other {
  if (other == [BLocation defaultInstance]) {
    return self;
  }
  if (other.hasCoordinate) {
    [self mergeCoordinate:other.coordinate];
  }
  if (other.hasAltitude) {
    [self setAltitude:other.altitude];
  }
  if (other.hasSpeed) {
    [self setSpeed:other.speed];
  }
  if (other.hasCourse) {
    [self setCourse:other.course];
  }
  if (other.hasTimestamp) {
    [self mergeTimestamp:other.timestamp];
  }
  if (other.hasPlacename) {
    [self setPlacename:other.placename];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BLocationBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BLocationBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        BCoordinateBuilder* subBuilder = [BCoordinate builder];
        if (self.hasCoordinate) {
          [subBuilder mergeFrom:self.coordinate];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setCoordinate:[subBuilder buildPartial]];
        break;
      }
      case 17: {
        [self setAltitude:[input readDouble]];
        break;
      }
      case 25: {
        [self setSpeed:[input readDouble]];
        break;
      }
      case 33: {
        [self setCourse:[input readDouble]];
        break;
      }
      case 42: {
        BTimestampBuilder* subBuilder = [BTimestamp builder];
        if (self.hasTimestamp) {
          [subBuilder mergeFrom:self.timestamp];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setTimestamp:[subBuilder buildPartial]];
        break;
      }
      case 50: {
        [self setPlacename:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasCoordinate {
  return resultLocation.hasCoordinate;
}
- (BCoordinate*) coordinate {
  return resultLocation.coordinate;
}
- (BLocationBuilder*) setCoordinate:(BCoordinate*) value {
  resultLocation.hasCoordinate = YES;
  resultLocation.coordinate = value;
  return self;
}
- (BLocationBuilder*) setCoordinateBuilder:(BCoordinateBuilder*) builderForValue {
  return [self setCoordinate:[builderForValue build]];
}
- (BLocationBuilder*) mergeCoordinate:(BCoordinate*) value {
  if (resultLocation.hasCoordinate &&
      resultLocation.coordinate != [BCoordinate defaultInstance]) {
    resultLocation.coordinate =
      [[[BCoordinate builderWithPrototype:resultLocation.coordinate] mergeFrom:value] buildPartial];
  } else {
    resultLocation.coordinate = value;
  }
  resultLocation.hasCoordinate = YES;
  return self;
}
- (BLocationBuilder*) clearCoordinate {
  resultLocation.hasCoordinate = NO;
  resultLocation.coordinate = [BCoordinate defaultInstance];
  return self;
}
- (BOOL) hasAltitude {
  return resultLocation.hasAltitude;
}
- (Float64) altitude {
  return resultLocation.altitude;
}
- (BLocationBuilder*) setAltitude:(Float64) value {
  resultLocation.hasAltitude = YES;
  resultLocation.altitude = value;
  return self;
}
- (BLocationBuilder*) clearAltitude {
  resultLocation.hasAltitude = NO;
  resultLocation.altitude = 0;
  return self;
}
- (BOOL) hasSpeed {
  return resultLocation.hasSpeed;
}
- (Float64) speed {
  return resultLocation.speed;
}
- (BLocationBuilder*) setSpeed:(Float64) value {
  resultLocation.hasSpeed = YES;
  resultLocation.speed = value;
  return self;
}
- (BLocationBuilder*) clearSpeed {
  resultLocation.hasSpeed = NO;
  resultLocation.speed = 0;
  return self;
}
- (BOOL) hasCourse {
  return resultLocation.hasCourse;
}
- (Float64) course {
  return resultLocation.course;
}
- (BLocationBuilder*) setCourse:(Float64) value {
  resultLocation.hasCourse = YES;
  resultLocation.course = value;
  return self;
}
- (BLocationBuilder*) clearCourse {
  resultLocation.hasCourse = NO;
  resultLocation.course = 0;
  return self;
}
- (BOOL) hasTimestamp {
  return resultLocation.hasTimestamp;
}
- (BTimestamp*) timestamp {
  return resultLocation.timestamp;
}
- (BLocationBuilder*) setTimestamp:(BTimestamp*) value {
  resultLocation.hasTimestamp = YES;
  resultLocation.timestamp = value;
  return self;
}
- (BLocationBuilder*) setTimestampBuilder:(BTimestampBuilder*) builderForValue {
  return [self setTimestamp:[builderForValue build]];
}
- (BLocationBuilder*) mergeTimestamp:(BTimestamp*) value {
  if (resultLocation.hasTimestamp &&
      resultLocation.timestamp != [BTimestamp defaultInstance]) {
    resultLocation.timestamp =
      [[[BTimestamp builderWithPrototype:resultLocation.timestamp] mergeFrom:value] buildPartial];
  } else {
    resultLocation.timestamp = value;
  }
  resultLocation.hasTimestamp = YES;
  return self;
}
- (BLocationBuilder*) clearTimestamp {
  resultLocation.hasTimestamp = NO;
  resultLocation.timestamp = [BTimestamp defaultInstance];
  return self;
}
- (BOOL) hasPlacename {
  return resultLocation.hasPlacename;
}
- (NSString*) placename {
  return resultLocation.placename;
}
- (BLocationBuilder*) setPlacename:(NSString*) value {
  resultLocation.hasPlacename = YES;
  resultLocation.placename = value;
  return self;
}
- (BLocationBuilder*) clearPlacename {
  resultLocation.hasPlacename = NO;
  resultLocation.placename = @"";
  return self;
}
@end

@interface BVoid ()
@property (strong) NSString* text;
@end

@implementation BVoid

- (BOOL) hasText {
  return !!hasText_;
}
- (void) setHasText:(BOOL) _value_ {
  hasText_ = !!_value_;
}
@synthesize text;
- (instancetype) init {
  if ((self = [super init])) {
    self.text = @"";
  }
  return self;
}
static BVoid* defaultBVoidInstance = nil;
+ (void) initialize {
  if (self == [BVoid class]) {
    defaultBVoidInstance = [[BVoid alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBVoidInstance;
}
- (instancetype) defaultInstance {
  return defaultBVoidInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasText) {
    [output writeString:1 value:self.text];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasText) {
    size_ += computeStringSize(1, self.text);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BVoid*) parseFromData:(NSData*) data {
  return (BVoid*)[[[BVoid builder] mergeFromData:data] build];
}
+ (BVoid*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BVoid*)[[[BVoid builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BVoid*) parseFromInputStream:(NSInputStream*) input {
  return (BVoid*)[[[BVoid builder] mergeFromInputStream:input] build];
}
+ (BVoid*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BVoid*)[[[BVoid builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BVoid*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BVoid*)[[[BVoid builder] mergeFromCodedInputStream:input] build];
}
+ (BVoid*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BVoid*)[[[BVoid builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BVoidBuilder*) builder {
  return [[BVoidBuilder alloc] init];
}
+ (BVoidBuilder*) builderWithPrototype:(BVoid*) prototype {
  return [[BVoid builder] mergeFrom:prototype];
}
- (BVoidBuilder*) builder {
  return [BVoid builder];
}
- (BVoidBuilder*) toBuilder {
  return [BVoid builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasText) {
    [output appendFormat:@"%@%@: %@\n", indent, @"text", self.text];
  }
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasText) {
    [dictionary setObject: self.text forKey: @"text"];
  }
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BVoid class]]) {
    return NO;
  }
  BVoid *otherMessage = other;
  return
      self.hasText == otherMessage.hasText &&
      (!self.hasText || [self.text isEqual:otherMessage.text]) &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasText) {
    hashCode = hashCode * 31 + [self.text hash];
  }
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BVoidBuilder()
@property (strong) BVoid* resultVoid;
@end

@implementation BVoidBuilder
@synthesize resultVoid;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultVoid = [[BVoid alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultVoid;
}
- (BVoidBuilder*) clear {
  self.resultVoid = [[BVoid alloc] init];
  return self;
}
- (BVoidBuilder*) clone {
  return [BVoid builderWithPrototype:resultVoid];
}
- (BVoid*) defaultInstance {
  return [BVoid defaultInstance];
}
- (BVoid*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BVoid*) buildPartial {
  BVoid* returnMe = resultVoid;
  self.resultVoid = nil;
  return returnMe;
}
- (BVoidBuilder*) mergeFrom:(BVoid*) other {
  if (other == [BVoid defaultInstance]) {
    return self;
  }
  if (other.hasText) {
    [self setText:other.text];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BVoidBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BVoidBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setText:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasText {
  return resultVoid.hasText;
}
- (NSString*) text {
  return resultVoid.text;
}
- (BVoidBuilder*) setText:(NSString*) value {
  resultVoid.hasText = YES;
  resultVoid.text = value;
  return self;
}
- (BVoidBuilder*) clearText {
  resultVoid.hasText = NO;
  resultVoid.text = @"";
  return self;
}
@end

@interface BKeyValue ()
@property (strong) NSString* key;
@property (strong) NSMutableArray * valueArray;
@end

@implementation BKeyValue

- (BOOL) hasKey {
  return !!hasKey_;
}
- (void) setHasKey:(BOOL) _value_ {
  hasKey_ = !!_value_;
}
@synthesize key;
@synthesize valueArray;
@dynamic value;
- (instancetype) init {
  if ((self = [super init])) {
    self.key = @"";
  }
  return self;
}
static BKeyValue* defaultBKeyValueInstance = nil;
+ (void) initialize {
  if (self == [BKeyValue class]) {
    defaultBKeyValueInstance = [[BKeyValue alloc] init];
  }
}
+ (instancetype) defaultInstance {
  return defaultBKeyValueInstance;
}
- (instancetype) defaultInstance {
  return defaultBKeyValueInstance;
}
- (NSArray *)value {
  return valueArray;
}
- (NSString*)valueAtIndex:(NSUInteger)index {
  return [valueArray objectAtIndex:index];
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasKey) {
    [output writeString:1 value:self.key];
  }
  [self.valueArray enumerateObjectsUsingBlock:^(NSString *element, NSUInteger idx, BOOL *stop) {
    [output writeString:2 value:element];
  }];
  [self.unknownFields writeToCodedOutputStream:output];
}
- (SInt32) serializedSize {
  __block SInt32 size_ = memoizedSerializedSize;
  if (size_ != -1) {
    return size_;
  }

  size_ = 0;
  if (self.hasKey) {
    size_ += computeStringSize(1, self.key);
  }
  {
    __block SInt32 dataSize = 0;
    const NSUInteger count = self.valueArray.count;
    [self.valueArray enumerateObjectsUsingBlock:^(NSString *element, NSUInteger idx, BOOL *stop) {
      dataSize += computeStringSizeNoTag(element);
    }];
    size_ += dataSize;
    size_ += (SInt32)(1 * count);
  }
  size_ += self.unknownFields.serializedSize;
  memoizedSerializedSize = size_;
  return size_;
}
+ (BKeyValue*) parseFromData:(NSData*) data {
  return (BKeyValue*)[[[BKeyValue builder] mergeFromData:data] build];
}
+ (BKeyValue*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BKeyValue*)[[[BKeyValue builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (BKeyValue*) parseFromInputStream:(NSInputStream*) input {
  return (BKeyValue*)[[[BKeyValue builder] mergeFromInputStream:input] build];
}
+ (BKeyValue*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BKeyValue*)[[[BKeyValue builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BKeyValue*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (BKeyValue*)[[[BKeyValue builder] mergeFromCodedInputStream:input] build];
}
+ (BKeyValue*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (BKeyValue*)[[[BKeyValue builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (BKeyValueBuilder*) builder {
  return [[BKeyValueBuilder alloc] init];
}
+ (BKeyValueBuilder*) builderWithPrototype:(BKeyValue*) prototype {
  return [[BKeyValue builder] mergeFrom:prototype];
}
- (BKeyValueBuilder*) builder {
  return [BKeyValue builder];
}
- (BKeyValueBuilder*) toBuilder {
  return [BKeyValue builderWithPrototype:self];
}
- (void) writeDescriptionTo:(NSMutableString*) output withIndent:(NSString*) indent {
  if (self.hasKey) {
    [output appendFormat:@"%@%@: %@\n", indent, @"key", self.key];
  }
  [self.valueArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    [output appendFormat:@"%@%@: %@\n", indent, @"value", obj];
  }];
  [self.unknownFields writeDescriptionTo:output withIndent:indent];
}
- (void) storeInDictionary:(NSMutableDictionary *)dictionary {
  if (self.hasKey) {
    [dictionary setObject: self.key forKey: @"key"];
  }
  [dictionary setObject:self.value forKey: @"value"];
  [self.unknownFields storeInDictionary:dictionary];
}
- (BOOL) isEqual:(id)other {
  if (other == self) {
    return YES;
  }
  if (![other isKindOfClass:[BKeyValue class]]) {
    return NO;
  }
  BKeyValue *otherMessage = other;
  return
      self.hasKey == otherMessage.hasKey &&
      (!self.hasKey || [self.key isEqual:otherMessage.key]) &&
      [self.valueArray isEqualToArray:otherMessage.valueArray] &&
      (self.unknownFields == otherMessage.unknownFields || (self.unknownFields != nil && [self.unknownFields isEqual:otherMessage.unknownFields]));
}
- (NSUInteger) hash {
  __block NSUInteger hashCode = 7;
  if (self.hasKey) {
    hashCode = hashCode * 31 + [self.key hash];
  }
  [self.valueArray enumerateObjectsUsingBlock:^(NSString *element, NSUInteger idx, BOOL *stop) {
    hashCode = hashCode * 31 + [element hash];
  }];
  hashCode = hashCode * 31 + [self.unknownFields hash];
  return hashCode;
}
@end

@interface BKeyValueBuilder()
@property (strong) BKeyValue* resultKeyValue;
@end

@implementation BKeyValueBuilder
@synthesize resultKeyValue;
- (instancetype) init {
  if ((self = [super init])) {
    self.resultKeyValue = [[BKeyValue alloc] init];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return resultKeyValue;
}
- (BKeyValueBuilder*) clear {
  self.resultKeyValue = [[BKeyValue alloc] init];
  return self;
}
- (BKeyValueBuilder*) clone {
  return [BKeyValue builderWithPrototype:resultKeyValue];
}
- (BKeyValue*) defaultInstance {
  return [BKeyValue defaultInstance];
}
- (BKeyValue*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (BKeyValue*) buildPartial {
  BKeyValue* returnMe = resultKeyValue;
  self.resultKeyValue = nil;
  return returnMe;
}
- (BKeyValueBuilder*) mergeFrom:(BKeyValue*) other {
  if (other == [BKeyValue defaultInstance]) {
    return self;
  }
  if (other.hasKey) {
    [self setKey:other.key];
  }
  if (other.valueArray.count > 0) {
    if (resultKeyValue.valueArray == nil) {
      resultKeyValue.valueArray = [[NSMutableArray alloc] initWithArray:other.valueArray];
    } else {
      [resultKeyValue.valueArray addObjectsFromArray:other.valueArray];
    }
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (BKeyValueBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (BKeyValueBuilder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSetBuilder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    SInt32 tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        [self setKey:[input readString]];
        break;
      }
      case 18: {
        [self addValue:[input readString]];
        break;
      }
    }
  }
}
- (BOOL) hasKey {
  return resultKeyValue.hasKey;
}
- (NSString*) key {
  return resultKeyValue.key;
}
- (BKeyValueBuilder*) setKey:(NSString*) value {
  resultKeyValue.hasKey = YES;
  resultKeyValue.key = value;
  return self;
}
- (BKeyValueBuilder*) clearKey {
  resultKeyValue.hasKey = NO;
  resultKeyValue.key = @"";
  return self;
}
- (NSMutableArray *)value {
  return resultKeyValue.valueArray;
}
- (NSString*)valueAtIndex:(NSUInteger)index {
  return [resultKeyValue valueAtIndex:index];
}
- (BKeyValueBuilder *)addValue:(NSString*)value {
  if (resultKeyValue.valueArray == nil) {
    resultKeyValue.valueArray = [[NSMutableArray alloc]init];
  }
  [resultKeyValue.valueArray addObject:value];
  return self;
}
- (BKeyValueBuilder *)setValueArray:(NSArray *)array {
  resultKeyValue.valueArray = [[NSMutableArray alloc] initWithArray:array];
  return self;
}
- (BKeyValueBuilder *)clearValue {
  resultKeyValue.valueArray = nil;
  return self;
}
@end


// @@protoc_insertion_point(global_scope)
